from lifton import extract_features
import argparse
from pyfaidx import Fasta, Faidx
from intervaltree import Interval, IntervalTree
import copy

from lifton import align, adjust_cds_boundaries, fix_trans_annotation, lifton_class, lifton_utils

def parse_args(arglist):
    print("arglist: ", arglist)
    parser = argparse.ArgumentParser(description='Lift features from one genome assembly to another')
    parser.add_argument('target', help='target fasta genome to lift genes to')

    # refrgrp = parser.add_argument_group('Required input (annotation)')
    # mxgrp = refrgrp.add_mutually_exclusive_group(required=True)
    # mxgrp.add_argument(
    #     '-g', metavar='GFF', help='annotation file to lift over in GFF or GTF format'
    # )
    # mxgrp.add_argument(
    #     '-db', metavar='DB', help='name of feature database; if not specified, the -g '
    #                               'argument must be provided and a database will be built automatically'
    # )

    outgrp = parser.add_argument_group('Output')
    outgrp.add_argument(
        '-o', '--output', default='stdout', metavar='FILE',
        help='write output to FILE in same format as input; by default, output is written to terminal (stdout)'
    )

    outgrp.add_argument(
        '-d', '--dir', default='intermediate_files', metavar='DIR',
        help='name of directory to save intermediate fasta and SAM files; default is "intermediate_files"',
    )

    parser.add_argument('-V', '--version', help='show program version', action='version', version='v1.6.3')
    parser.add_argument(
        '-t', '--threads', default=1, type=int, metavar='P', help='use p parallel processes to accelerate alignment; by default p=1'
    )

    parser.add_argument(
        '-p', '--proteins', metavar='fasta', required=True,
        help='the reference protein sequences.'
    )

    liftoffrefrgrp = parser.add_argument_group('Required input (Liftoff annotation)')

    liftoffgrp = liftoffrefrgrp.add_mutually_exclusive_group(required=True)
    liftoffgrp.add_argument(
        '-l', '--liftoff', metavar='gff',
        help='the annotation generated by Liftoff'
    )
    liftoffgrp.add_argument(
        '-ldb', '--liftoffdb', metavar='gff-DB',
        help='name of Liftoff database; if not specified, the -liftoff '
                                  'argument must be provided and a database will be built automatically'
    )

    miniprotrefrgrp = parser.add_argument_group('Required input (miniprot annotation)')

    miniprotgrp = miniprotrefrgrp.add_mutually_exclusive_group(required=True)
    miniprotgrp.add_argument(
        '-m', '--miniprot', metavar='gff',
        help='the annotation generated by miniprot'
    )
    miniprotgrp.add_argument(
        '-mdb', '--miniprotdb', metavar='gff-DB',
        help='name of miniprot database; if not specified, the -miniprot '
                                  'argument must be provided and a database will be built automatically'
    )

    parser._positionals.title = 'Required input (sequences)'
    parser._optionals.title = 'Miscellaneous settings'

    parser._action_groups = [parser._positionals, liftoffrefrgrp, miniprotrefrgrp, outgrp, parser._optionals]
    args = parser.parse_args(arglist)
    return args



def run_all_liftoff_steps(args):
    ref_chroms = []
    fai = Fasta(args.target)
    print("fai: ", fai.keys())
    print(args.output)
    print(args.dir)

    fai_protein = Fasta(args.proteins)

    l_feature_db, m_feature_db = extract_features.extract_features_to_fix(ref_chroms, args)

    fw = open(args.output, "w")
    # fw_protein = open("lifton_protein.gff3", "w")

    
    ################################
    # Step 1: Creating miniprot 2 Liftoff ID mapping
    ################################
    m_id_dict = {}
    aa_id_2_m_id_dict = {}
    for feature in m_feature_db.features_of_type("mRNA"):
        # Print all attributes and their values for the feature
        miniprot_id = feature["ID"][0]

        aa_trans_id = str(feature.attributes["Target"][0]).split(" ")[0]
        # print("aa_trans_id: ", aa_trans_id)
        if aa_trans_id in m_id_dict.keys():
            m_id_dict[aa_trans_id].append(miniprot_id)
        else:
            m_id_dict[aa_trans_id] = [miniprot_id]
        aa_id_2_m_id_dict[miniprot_id] = aa_trans_id

    ###################################
    # Printing the miniprot dictionary
    ###################################
    # for key, vals in m_id_dict.items():
    #     print("key : ", key)
    #     print("vals: ", vals)


    ################################
    # Iterating Liftoff transcript
    ################################
    # # Iterate through the features in the database and collect unique feature types
    # print("l_feature_db.features_of_type('mRNA')", l_feature_db.all_features())
    # for feature in l_feature_db.all_features(strand="+"):
    # # for feature in l_feature_db.features_of_type("mRNA"):
    #     print("feature ", feature)


    # print(" m_feature_db.features_of_type('mRNA'):",  m_feature_db.all_features())
    # for feature in m_feature_db.features_of_type("mRNA"):
    #     print("feature ", feature)
    
    ################################
    # Step 2: Initializing intervaltree
    ################################
    tree_dict = {}
    chr_num_ls = [*range(1, 23)] 
    chr_num_ls += ['X', 'Y', 'M']
    for i in chr_num_ls:
        tree = IntervalTree()
        tree_dict["chr" + str(i)] = tree

    # print(tree_dict)

    ################################
    # Step 3: Adding gene intervals into intervaltree
    ################################
    for gene in l_feature_db.features_of_type('gene'):
        gene_interval = Interval(gene.start, gene.end, gene.attributes["ID"][0])
        chromosome = gene.seqid
        tree_dict[chromosome].add(gene_interval)




    ################################
    # Step 4: Iterating gene entries & fixing CDS lists
    ################################
    gene_copy_num_dict = {}

    gene_info_dict = {}
    trans_info_dict = {}
    trans_2_gene_dict = {}

    LIFTOFF_TOTAL_GENE_COUNT = 0
    LIFTOFF_ONLY_GENE_COUNT = 0
    LIFTOFF_MINIPROT_FIXED_GENE_COUNT = 0

    for gene in l_feature_db.features_of_type('gene'):#, limit=("chr6", 35729821, 35746565)):
        LIFTOFF_TOTAL_GENE_COUNT += 1
        chromosome = gene.seqid
        gene_id = gene.attributes["ID"][0]
        gene_id_base = lifton_utils.get_ID_base(gene_id)
        # print("&& gene_id      : ", gene_id)
        # print("&& gene_id_base : ", gene_id_base)

        ################################
        # Step 4.1: Creating gene copy number dictionary
        ################################
        if gene_id_base in gene_copy_num_dict.keys():
            gene_copy_num_dict[gene_id_base] += 1
        else:
            gene_copy_num_dict[gene_id_base] = 0

        ################################
        # Step 4.2: Creating LiftOn gene & gene_info
        ################################
        lifton_gene = lifton_class.Lifton_GENE(gene)
        gene_info = copy.deepcopy(gene)
        lifton_gene_info = lifton_class.Lifton_GENE_info(gene_info, gene_id_base)
        gene_info_dict[gene_id_base] = lifton_gene_info
        
        ################################
        # Step 4.3: Adding LiftOn transcripts
        ################################
        # Assumption that all 1st level are transcripts
        transcripts = l_feature_db.children(gene, level=1)
        for transcript in list(transcripts):
            
            lifton_gene.add_transcript(transcript)
            transcript_id = transcript["ID"][0]
            transcript_id_base = lifton_utils.get_trans_ID_base(transcript_id)

            # print("&& transcript_id      : ", transcript_id)
            # print("&& transcript_id_base : ", transcript_id_base)

            transcript_info = copy.deepcopy(transcript)
            lifton_trans_info = lifton_class.Lifton_TRANS_info(transcript_info, transcript_id_base, gene_id_base)

            trans_2_gene_dict[transcript_id_base] = gene_id_base
            trans_info_dict[transcript_id_base] = lifton_trans_info

        
            ###########################
            # Step 4.4: Adding exons
            ###########################
            exons = l_feature_db.children(transcript, featuretype='exon')  # Replace 'exon' with the desired child feature type
            for exon in list(exons):
                lifton_gene.add_exon(transcript_id, exon)

            
            ###########################
            # Step 4.5: Adding CDS
            ###########################
            cdss = l_feature_db.children(transcript, featuretype='CDS')  # Replace 'exon' with the desired child feature type
            cds_num = 0
            for cds in list(cdss):
                cds_num += 1
                lifton_gene.add_cds(transcript_id, cds)


            #############################################
            # Step 4.6: Processing transcript
            #   1. There are CDS features
            #   2. transcript ID is in both miniprot & Liftoff & protein FASTA file
            #############################################
            if (cds_num > 0) and (transcript_id in m_id_dict.keys()) and (transcript_id in fai_protein.keys()):
                ################################
                # Step 4.6.1: Protein sequences are in both Liftoff and miniprot
                #   Fix the protein sequences
                ################################
                
                ################################
                # Step 4.6.2: liftoff transcript alignment
                ################################
                l_lifton_aln = align.parasail_align("liftoff", l_feature_db, transcript, fai, fai_protein, transcript_id)

                ################################
                # Step 4.6.3: miniprot transcript alignment
                ################################
                m_ids = m_id_dict[transcript_id]

                for m_id in m_ids:
                    m_entry = m_feature_db[m_id]
                    if m_entry.seqid != chromosome:
                        continue
                    
                    m_lifton_aln = align.parasail_align("miniprot", m_feature_db, m_entry, fai, fai_protein, transcript_id)
                    overlap = lifton_utils.segments_overlap((m_entry.start, m_entry.end), (transcript.start, transcript.end))


                    ############################################
                    # miniprot and Liftoff transcript overlap
                    #   => fix & update CDS list
                    ############################################
                    if overlap and m_entry.seqid == transcript.seqid:
                        LIFTOFF_MINIPROT_FIXED_GENE_COUNT += 1
                        # Check reference overlapping status
                        # 1. Check it the transcript overlapping with the next gene
                        # Check the miniprot protein overlapping status
                        # The case I should not process the transcript 
                        # 1. The Liftoff does not overlap with other gene
                        # 2. The miniprot protein overlap the other gene
                        ovps_liftoff = tree_dict[chromosome].overlap(transcript.start, transcript.end)
                        ovps_miniprot = tree_dict[chromosome].overlap(m_entry.start, m_entry.end)
                        if len(ovps_liftoff) == 1 and len(ovps_miniprot) > 1:
                            # print("Liftoff & miniprot disagree too much => skip")
                            # print(transcript)
                            continue                            

                        cds_list = fix_trans_annotation.fix_transcript_annotation(m_lifton_aln, l_lifton_aln, fai, fw)
                        lifton_gene.update_cds_list(transcript_id, cds_list)
            else:
                LIFTOFF_ONLY_GENE_COUNT += 1
                # print("==> Liftoff only")
            #     ################################
            #     # Keep the transcript as it is.
            #     #   (1) do not have proper protein sequences.
            #     #   (2) transcript_id not in proteins
            #     #   (3) transcript ID not in miniprot 
            #     ################################
            #     pass

        ###########################
        # Step 4.7: Writing out LiftOn entries
        ###########################
        lifton_gene.write_entry(fw)
        # print("Final!!")
        # lifton_gene.print_gene()


        ###########################
        # Step 4.8: Adding LiftOn intervals
        ###########################
        gene_interval = Interval(lifton_gene.entry.start, lifton_gene.entry.end, gene_id)
        tree_dict[chromosome].add(gene_interval)


    # print("gene_copy_num_dict: ", gene_copy_num_dict)
    # print("trans_2_gene_dict: ", trans_2_gene_dict)
    # print("gene_info_dict : ", gene_info_dict)
    # print("trans_info_dict: ", trans_info_dict)
    
    # for key, val in gene_copy_num_dict.items():
    #     if val > 0:
    #         print(key, val)




    ################################
    # Step 5: Finding extra copies
    ################################
    EXTRA_COPY_MINIPROT_COUNT = 0
    NEW_LOCUS_MINIPROT_COUNT = 0
    for mtrans in m_feature_db.features_of_type('mRNA'):#, limit=("chr1", 0, 250000000)):
        chromosome = mtrans.seqid
        mtrans_id = mtrans.attributes["ID"][0]
        mtrans_interval = Interval(mtrans.start, mtrans.end, mtrans_id)
        ovps = tree_dict[chromosome].overlap(mtrans_interval)

        # Add new transcript loci into interval tree
        gene_interval = Interval(mtrans.start, mtrans.end, mtrans.attributes["ID"])
        tree_dict[chromosome].add(gene_interval)

        if len(ovps) == 0:

            extra_cp_trans_id = aa_id_2_m_id_dict[mtrans_id]

            gene_entry_base = copy.deepcopy(mtrans)
            trans_entry_base = copy.deepcopy(mtrans)
            # Find the extra copy for know gene
            if extra_cp_trans_id in trans_info_dict.keys():
                EXTRA_COPY_MINIPROT_COUNT += 1
                extra_cp_gene_id = trans_2_gene_dict[extra_cp_trans_id] 

                #######################################
                # Step 5.1: Create the gene entry
                #######################################
                gene_attrs = gene_info_dict[extra_cp_gene_id]
                # print("gene_attrs : ", gene_attrs)
                Lifton_gene_ecp = lifton_class.Lifton_GENE(gene_entry_base)
                new_extra_cp_gene_id = Lifton_gene_ecp.update_gene_info(extra_cp_gene_id, chromosome, mtrans.start, mtrans.end, gene_attrs, gene_copy_num_dict)


                #######################################
                # Step 5.2: Create the transcript entry
                #######################################
                trans_attrs = trans_info_dict[extra_cp_trans_id]
                # print("trans_attrs: ", trans_attrs)
                new_extra_cp_trans_id = Lifton_gene_ecp.create_new_transcript(extra_cp_gene_id, extra_cp_trans_id, trans_entry_base, chromosome, mtrans.start, mtrans.end, trans_attrs, gene_copy_num_dict)

                #######################################
                # Step 5.3: Create the exon entry
                #######################################

                #######################################
                # Step 5.4: Create the CDS entry
                #######################################
                cdss = m_feature_db.children(mtrans, featuretype='CDS')  # Replace 'exon' with the desired child feature type
                # print("cdss len: ", len(cdss))
                for cds in list(cdss):

                    # entry.attributes["ID"]
                    Lifton_gene_ecp.add_exon(new_extra_cp_trans_id, cds)
                    cds_copy = copy.deepcopy(cds)
                    Lifton_gene_ecp.add_cds(new_extra_cp_trans_id, cds_copy)
                Lifton_gene_ecp.write_entry(fw)

            else:
                NEW_LOCUS_MINIPROT_COUNT += 1
                #######################################
                # Step 5.1: Create the gene entry
                #######################################
                extra_cp_gene_id = f"gene-LiftOn-{NEW_LOCUS_MINIPROT_COUNT}"

                Lifton_gene_ecp = lifton_class.Lifton_GENE(gene_entry_base)
                new_extra_cp_gene_id = Lifton_gene_ecp.update_gene_info_novel(extra_cp_gene_id, chromosome, mtrans.start, mtrans.end)

                # print("new_extra_cp_gene_id: ", new_extra_cp_gene_id)


                #######################################
                # Step 5.2: Create the transcript entry
                #######################################
                new_extra_cp_trans_id = Lifton_gene_ecp.create_new_transcript_novel(extra_cp_gene_id, extra_cp_trans_id, trans_entry_base, chromosome, mtrans.start, mtrans.end)

                #######################################
                # Step 5.3: Create the exon entry
                #######################################
                #######################################
                # Step 5.4: Create the CDS entry
                #######################################
                cdss = m_feature_db.children(mtrans, featuretype='CDS')  # Replace 'exon' with the desired child feature type
                # print("cdss len: ", len(cdss))
                for cds in list(cdss):
                    Lifton_gene_ecp.add_exon(extra_cp_trans_id, cds)
                    cds_copy = copy.deepcopy(cds)
                    Lifton_gene_ecp.add_cds(extra_cp_trans_id, cds_copy)

                Lifton_gene_ecp.write_entry(fw)

    print("Liftoff total gene loci\t\t\t: ", LIFTOFF_TOTAL_GENE_COUNT)
    print("Liftoff only gene loci\t\t\t: ", LIFTOFF_ONLY_GENE_COUNT)
    print("Liftoff & miniprot matched gene loci\t: ", LIFTOFF_MINIPROT_FIXED_GENE_COUNT)

    print("miniprot found extra copy gene loci\t: ", EXTRA_COPY_MINIPROT_COUNT)
    print("miniprot found new loci\t\t\t: ", NEW_LOCUS_MINIPROT_COUNT)

def main(arglist=None):
    args = parse_args(arglist)
    print("Run Lifton!!")
    print(args)
    run_all_liftoff_steps(args)