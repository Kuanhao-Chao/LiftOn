from lifton import extract_features, mapping, intervals, extra_copy
from intervaltree import Interval, IntervalTree
import argparse
from pyfaidx import Fasta, Faidx
import copy, os
from lifton import run_liftoff, run_miniprot, sequence
import subprocess
import sys
from Bio.Seq import Seq

from lifton import align, adjust_cds_boundaries, fix_trans_annotation, lifton_class, lifton_utils

def args_outgrp(parser):
    outgrp = parser.add_argument_group('* Output settings')
    outgrp.add_argument(
        '-o', '--output', default='stdout', metavar='FILE',
        help='write output to FILE in same format as input; by default, output is written to terminal (stdout)'
    )
    outgrp.add_argument(
        '-d', '--dir', default='intermediate_files', metavar='DIR',
        help='name of directory to save intermediate fasta and SAM files; default is "intermediate_files"',
    )
    return outgrp

def args_optional(parser):
    parser.add_argument('-V', '--version', help='show program version', action='version', version='v1.6.3')
    parser.add_argument(
        '-t', '--threads', default=1, type=int, metavar='P', help='use p parallel processes to accelerate alignment; by default p=1'
    )
    parser.add_argument('-f', '--features', metavar='TYPES', help='list of feature types to lift over')


def parse_args(arglist):
    print("arglist: ", arglist)
    parser = argparse.ArgumentParser(description='Lift features from one genome assembly to another')
    # parser.add_argument('target', help='target fasta genome to lift genes to')
    # parser.add_argument('reference', help='reference fasta genome to lift genes from')
    
    parser_outgrp = args_outgrp(parser)
    args_optional(parser)

    referencegrp = parser.add_argument_group('* Required input (Reference annotation)')    
    referencegrp.add_argument('-tg', '--target-genome', metavar='FASTA', 
                              help='target fasta genome to lift genes to', 
                              required=True)
    referencegrp.add_argument(
        '-rg', '--reference-genome', metavar='FASTA',
        help='reference fasta genome to lift genes from',
        required=True
    )
    refgff3grp = referencegrp.add_mutually_exclusive_group(required=True)
    refgff3grp.add_argument(
        '-g', '--reference', metavar='GFF',
        help='the reference annotation file to lift over in GFF or GTF format'
    )
    refgff3grp.add_argument(
        '-db', '--referencedb', metavar='GFF-DB',
        help='name of feature database; if not specified, the -g '
                        'argument must be provided and a database will be built automatically'
    )


    # ###################################
    # # This is for the subparser arguments
    # ###################################
    # subparsers = parser.add_subparsers(help='sub-command help')
    # sp = subparsers.add_parser('chain', help='\'chain\' command')
    # sp_outgrp = args_outgrp(sp)
    # args_optional(sp)

    # seqrefrgrp = sp.add_argument_group('* Required input (Sequences)')
    # seqrefrgrp.add_argument(
    #     '-tg', '--target-genome', metavar='FASTA', required=True,
    #     help='target fasta genome to lift genes to.'
    # )
    # seqrefrgrp.add_argument(
    #     '-p', '--proteins', metavar='FASTA', required=True,
    #     help='the reference protein sequences.'
    # )

    # liftoffrefrgrp = sp.add_argument_group('* Required input (Liftoff annotation)')
    # liftoffgrp = liftoffrefrgrp.add_mutually_exclusive_group(required=True)
    # liftoffgrp.add_argument(
    #     '-l', '--liftoff', metavar='gff',
    #     help='the annotation generated by Liftoff'
    # )
    # liftoffgrp.add_argument(
    #     '-ldb', '--liftoffdb', metavar='gff-DB',
    #     help='name of Liftoff gffutils database; if not specified, the -liftoff '
    #                               'argument must be provided and a database will be built automatically'
    # )

    # miniprotrefrgrp = sp.add_argument_group('* Required input (miniprot annotation)')
    # miniprotgrp = miniprotrefrgrp.add_mutually_exclusive_group(required=True)
    # miniprotgrp.add_argument(
    #     '-m', '--miniprot', metavar='gff',
    #     help='the annotation generated by miniprot'
    # )
    # miniprotgrp.add_argument(
    #     '-mdb', '--miniprotdb', metavar='gff-DB',
    #     help='name of miniprot gffutils database; if not specified, the -miniprot '
    #                               'argument must be provided and a database will be built automatically'
    # )
    # sp._action_groups = [seqrefrgrp, liftoffrefrgrp, miniprotrefrgrp, sp_outgrp, sp._optionals]


    # parser._positionals.title = '* Required input (sequences)'
    parser._optionals.title = '* Miscellaneous settings'
    parser._action_groups = [referencegrp, parser_outgrp, parser._optionals]

    # parser._action_groups = [parser._positionals, referencegrp, proteinrefrgrp, liftoffrefrgrp, miniprotrefrgrp, outgrp, parser._optionals]
    args = parser.parse_args(arglist)
    return args


def run_all_lifton_steps(args):
    ref_chroms = []

    ################################
    # Step 0: end2end mode
    ################################
    tgt_genome = args.target_genome
    ref_genome = args.reference_genome
    outdir = os.path.dirname(args.output)
    outdir = outdir if outdir is not "" else "."
    print("outdir: ", outdir)

    tgt_fai = Fasta(tgt_genome)
    ref_fai = Fasta(ref_genome)

    print("tgt_genome: ", tgt_genome)
    print("ref_genome: ", ref_genome)
    

    ################################
    # Checkk if liftoff and miniprot are installed
    ################################
    # print(run_liftoff.run_all_liftoff_steps)
    liftoff_installed = run_liftoff.check_liftoff_installed()
    miniprot_installed = run_miniprot.check_miniprot_installed()

    print("liftoff_installed : ", liftoff_installed)
    print("miniprot_installed: ", miniprot_installed)

    if not liftoff_installed or not miniprot_installed:
        if not liftoff_installed:
            print("Liftoff is not properly installed.")
        if not miniprot_installed:
            print("Miniprot is not properly installed.")
        return sys.exit(1)


    ################################
    # Check if liftoff and miniprot results are generated
    ################################
    # liftoff_annotation = outdir + "/" + "liftoff.gff3_polished"
    # miniprot_annotation = outdir + "/" + "miniprot.gff3"

    liftoff_annotation = outdir + "/" + "liftoff.gff3"
    miniprot_annotation = outdir + "/" + "miniprot.gff3"

    print("liftoff_annotation  : ", liftoff_annotation)
    print("miniprot_annotation : ", miniprot_annotation)

    # liftoff_executed = run_liftoff.check_liftoff_installed()
    # miniprot_executed = run_miniprot.check_miniprot_installed()

    
    ################################
    # Execute liftoff and miniprot
    ################################
    if not os.path.exists(liftoff_annotation):
        run_liftoff.run_liftoff()

    if not os.path.exists(miniprot_annotation):
        run_miniprot.run_miniprot()

    ################################
    # Building database from the reference annotation
    ################################
    disable_transcripts = False
    disable_genes = True
    ref_feature_db = extract_features.build_database(args.referencedb, args.reference, disable_transcripts, disable_genes)
    print("ref_feature_db: ", ref_feature_db)

    ################################
    # Extract protein from reference annotation
    ################################
    protein_dict = {}
    features = lifton_utils.get_parent_features_to_lift(args.features)    
    
    # ref_proteins = sequence.SequenceDict(ref_feature_db, ref_fai, ['CDS', 'start_codon', 'stop_codon'], True)

    # print("ref_proteins: ", ref_proteins)

    for feature in features:
        for gene in ref_feature_db.features_of_type(feature):#, limit=("chr1", 0, 80478771)):
    #         LIFTOFF_TOTAL_GENE_COUNT += 1
    #         chromosome = gene.seqid
    #         gene_id = gene.attributes["ID"][0]
    #         gene_id_base = lifton_utils.get_ID_base(gene_id)

    #         ################################
    #         # Step 3.1: Creating gene copy number dictionary
    #         ################################
    #         lifton_utils.update_copy(gene_id_base, gene_copy_num_dict)

    #         ################################
    #         # Step 3.2: Creating LiftOn gene & gene_info
    #         ################################
    #         lifton_gene = lifton_class.Lifton_GENE(gene)
    #         gene_info = copy.deepcopy(gene)
    #         lifton_gene_info = lifton_class.Lifton_GENE_info(gene_info.attributes, gene_id_base)
    #         gene_info_dict[gene_id_base] = lifton_gene_info
            
    #         ################################
    #         # Step 3.3: Adding LiftOn transcripts
    #         ################################
    #         # Assumption that all 1st level are transcripts
            transcripts = ref_feature_db.children(gene, level=1)
            for transcript in list(transcripts):
                transcript_id = transcript.attributes["ID"][0]
                transcript_id_base = lifton_utils.get_ID_base(transcript_id)
                # ['CDS', 'start_codon', 'stop_codon']
                # print(transcript.attributes)
                
                cdss = ref_feature_db.children(transcript, featuretype='CDS')  # Replace 'exon' with the desired child feature type
                cds_num = 0

                for cds in list(cdss):
                    cds_num += 1

                    # Chaining the CDS features
                    p_seq = cds.entry.sequence(ref_fai)
                    p_seq = Seq(p_seq)
                    if cds.entry.strand == '-':
                        coding_seq = p_seq + coding_seq
                        # cdss_lens.insert(0, cds.entry.end - cds.entry.start + 1)
                    elif cds.entry.strand == '+':
                        coding_seq = coding_seq + p_seq
                        # cdss_lens.append(cds.entry.end - cds.entry.start + 1)

                ################################
                # Step 2: Translate the DNA sequence & get the reference protein sequence.
                ################################
                protein_seq = coding_seq.translate()
                peps = protein_seq.split("*")

    ################################
    # Running LiftOn algorithm
    ################################




    ################################
    # Step 0: Getting the arguments (required / optional)
    ################################
    # fai = Fasta(args.target)
    # fai_protein = Fasta(args.proteins)
    # l_feature_db, m_feature_db = extract_features.extract_features_to_fix(ref_chroms, args)

    # print("args.features: ", args.features)
    # print("args.threads: ", args.threads)
    # print("args.proteins: ", args.proteins)

    # outdir = os.path.dirname(args.output)
    # fw = open(args.output, "w")
    # fw_truncated = open(args.output+".truncated", "w")
    # fw_score = open(outdir+"/score.txt", "w")

    # ################################
    # # Step 1: Creating miniprot 2 Liftoff ID mapping
    # ################################
    # m_id_dict, aa_id_2_m_id_dict = mapping.id_mapping(m_feature_db)

    # ################################
    # # Step 2: Initializing intervaltree
    # ################################
    # tree_dict = intervals.initialize_interval_tree(l_feature_db)

    # # Dictionary for extra copy
    # gene_copy_num_dict = {}
    # trans_copy_num_dict = {}
    # gene_info_dict = {}
    # trans_info_dict = {}
    # trans_2_gene_dict = {}

    # LIFTOFF_TOTAL_GENE_COUNT = 0
    # LIFTOFF_TOTAL_TRANS_COUNT = 0
    # LIFTOFF_BAD_PROT_TRANS_COUNT = 0
    # LIFTOFF_GOOD_PROT_TRANS_COUNT = 0
    # LIFTOFF_NC_TRANS_COUNT = 0
    # LIFTOFF_OTHER_TRANS_COUNT = 0

    
    # LIFTON_BAD_PROT_TRANS_COUNT = 0
    # LIFTON_GOOD_PROT_TRANS_COUNT = 0
    # LIFTON_NC_TRANS_COUNT = 0
    # LIFTON_OTHER_TRANS_COUNT = 0
    # LIFTON_MINIPROT_FIXED_GENE_COUNT = 0

    # ################################
    # # Step 3: Iterating gene entries & fixing CDS lists
    # ################################
    # # For missing transcripts.
    # gene_copy_num_dict["gene-LiftOn"] = 0
    # features = lifton_utils.get_parent_features_to_lift(args.features)
    
    # fw_other_trans = open(outdir+"/other_trans.txt", "w")
    # fw_nc_trans = open(outdir+"/nc_trans.txt", "w")

    # for feature in features:
    #     for gene in l_feature_db.features_of_type(feature):#, limit=("chr1", 0, 80478771)):
    #         LIFTOFF_TOTAL_GENE_COUNT += 1
    #         chromosome = gene.seqid
    #         gene_id = gene.attributes["ID"][0]
    #         gene_id_base = lifton_utils.get_ID_base(gene_id)

    #         ################################
    #         # Step 3.1: Creating gene copy number dictionary
    #         ################################
    #         lifton_utils.update_copy(gene_id_base, gene_copy_num_dict)

    #         ################################
    #         # Step 3.2: Creating LiftOn gene & gene_info
    #         ################################
    #         lifton_gene = lifton_class.Lifton_GENE(gene)
    #         gene_info = copy.deepcopy(gene)
    #         lifton_gene_info = lifton_class.Lifton_GENE_info(gene_info.attributes, gene_id_base)
    #         gene_info_dict[gene_id_base] = lifton_gene_info
            
    #         ################################
    #         # Step 3.3: Adding LiftOn transcripts
    #         ################################
    #         # Assumption that all 1st level are transcripts
    #         transcripts = l_feature_db.children(gene, level=1)
    #         for transcript in list(transcripts):
    #             LIFTOFF_TOTAL_TRANS_COUNT += 1

    #             lifton_status = lifton_class.Lifton_Status()
    #             lifton_gene.add_transcript(transcript)
    #             transcript_id = transcript["ID"][0]
    #             transcript_id_base = lifton_utils.get_ID_base(transcript_id)

    #             ################################
    #             # Step 3.3.1: Creating trans copy number dictionary
    #             ################################
    #             lifton_utils.update_copy(transcript_id_base, trans_copy_num_dict)

    #             print("\ttranscript_id      : ", transcript_id)                
    #             print("&& transcript_id_base : ", transcript_id_base)

    #             transcript_info = copy.deepcopy(transcript)
    #             lifton_trans_info = lifton_class.Lifton_TRANS_info(transcript_info.attributes, transcript_id_base, gene_id_base)
    #             trans_2_gene_dict[transcript_id_base] = gene_id_base
    #             trans_info_dict[transcript_id_base] = lifton_trans_info

    #             ###########################
    #             # Step 3.4: Adding exons
    #             ###########################
    #             exons = l_feature_db.children(transcript, featuretype='exon')  # Replace 'exon' with the desired child feature type
    #             for exon in list(exons):
    #                 lifton_gene.add_exon(transcript_id, exon)
                
    #             ###########################
    #             # Step 3.5: Adding CDS
    #             ###########################
    #             cdss = l_feature_db.children(transcript, featuretype='CDS')  # Replace 'exon' with the desired child feature type
    #             cds_num = 0
    #             for cds in list(cdss):
    #                 cds_num += 1
    #                 lifton_gene.add_cds(transcript_id, cds)
                

    #             #############################################
    #             # Step 3.6: Processing transcript
    #             #############################################
    #             if (cds_num > 0) and (transcript_id_base in fai_protein.keys()):
    #                 l_lifton_aln = align.parasail_align("liftoff", l_feature_db, transcript, fai, fai_protein, transcript_id_base)

    #                 # SETTING Liftoff identity score
    #                 lifton_status.liftoff = l_lifton_aln.identity

    #                 if l_lifton_aln.identity < 1:
    #                     LIFTOFF_BAD_PROT_TRANS_COUNT += 1
    #                     #############################################
    #                     # Step 3.6.1: Liftoff annotation is not perfect
    #                     #############################################
    #                     lifton_status.annotation = "LiftOff_truncated"

    #                     # # Writing out truncated LiftOff annotation
    #                     # l_lifton_aln.write_alignment(outdir, "liftoff", transcript_id)
                    
    #                     m_lifton_aln, has_valid_miniprot = lifton_utils.LiftOn_check_miniprot_alignment(chromosome, transcript, lifton_status, m_id_dict, m_feature_db, tree_dict, fai, fai_protein, transcript_id_base)


    #                     #############################################
    #                     # Step 3.6.1.1: Running chaining algorithm if there are valid miniprot alignments
    #                     #############################################
    #                     if has_valid_miniprot:
    #                         LIFTON_MINIPROT_FIXED_GENE_COUNT += 1
    #                         cds_list = fix_trans_annotation.chaining_algorithm(l_lifton_aln, m_lifton_aln, fai, fw)
    #                         lifton_gene.update_cds_list(transcript_id, cds_list)
    #                         lifton_status.annotation = "LiftOff_miniprot_chaining_algorithm" 
    #                     else:
    #                         print("Has cds & protein & miniprot annotation; but no valid miniprot annotation!")
                            
    #                     #############################################
    #                     # Step 3.6.1.2: Check if there are mutations in the transcript
    #                     #############################################
    #                     on_lifton_aln, good_trans = lifton_gene.fix_truncated_protein(transcript_id, transcript_id_base, fai, fai_protein, lifton_status)
    #                     # SETTING LiftOn identity score
    #                     if on_lifton_aln.identity == 1:
    #                         LIFTON_GOOD_PROT_TRANS_COUNT += 1
    #                     elif on_lifton_aln.identity < 1:
    #                         # Writing out truncated LiftOn annotation
    #                         LIFTON_BAD_PROT_TRANS_COUNT += 1
    #                         on_lifton_aln.write_alignment(outdir, "lifton", transcript_id)                            

    #                 elif l_lifton_aln.identity == 1:
    #                     #############################################
    #                     # Step 3.6.2: Liftoff annotation is perfect
    #                     #############################################
    #                     LIFTOFF_GOOD_PROT_TRANS_COUNT += 1
    #                     LIFTON_GOOD_PROT_TRANS_COUNT += 1

    #                     m_lifton_aln, has_valid_miniprot = lifton_utils.LiftOn_check_miniprot_alignment(chromosome, transcript, lifton_status, m_id_dict, m_feature_db, tree_dict, fai, fai_protein, transcript_id_base)

    #                     # SETTING LiftOn identity score => Same as Liftoff
    #                     lifton_status.lifton = l_lifton_aln.identity
    #                     lifton_status.annotation = "LiftOff_identical"
    #                     lifton_status.status = "identical"

    #                 fw_score.write(f"{transcript_id}\t{lifton_status.liftoff}\t{lifton_status.miniprot}\t{lifton_status.lifton}\t{lifton_status.annotation}\t{lifton_status.status}\t{transcript.seqid}:{transcript.start}-{transcript.end}\n")
                
    #             else:
    #                 # Only liftoff annotation
    #                 print("No cds || no protein")
    #                 if (cds_num > 0):
    #                     LIFTOFF_OTHER_TRANS_COUNT += 1
    #                     LIFTON_OTHER_TRANS_COUNT += 1
    #                     lifton_status.annotation = "LiftOff_no_ref_protein"
    #                     lifton_status.status = "no_ref_protein"
    #                     fw_other_trans.write(transcript_id+"\n")

    #                 else:
    #                     LIFTOFF_NC_TRANS_COUNT += 1
    #                     LIFTON_NC_TRANS_COUNT += 1
    #                     lifton_status.annotation = "LiftOff_nc_transcript"
    #                     lifton_status.status = "nc_transcript"
    #                     fw_nc_trans.write(transcript_id+"\n")



    #         ###########################
    #         # Step 4.7: Writing out LiftOn entries
    #         ###########################
    #         lifton_gene.write_entry(fw)
    #         # print("Final!!")
    #         # lifton_gene.print_gene()

    #         ###########################
    #         # Step 4.8: Adding LiftOn intervals
    #         ###########################
    #         gene_interval = Interval(lifton_gene.entry.start, lifton_gene.entry.end, gene_id)
    #         tree_dict[chromosome].add(gene_interval)


    # ################################
    # # Step 5: Finding extra copies
    # ################################
    # EXTRA_COPY_MINIPROT_COUNT = 0 
    # NEW_LOCUS_MINIPROT_COUNT = 0
    # # EXTRA_COPY_MINIPROT_COUNT, NEW_LOCUS_MINIPROT_COUNT = extra_copy.find_extra_copy(m_feature_db, tree_dict, aa_id_2_m_id_dict, gene_info_dict, trans_info_dict, trans_2_gene_dict, gene_copy_num_dict, trans_copy_num_dict, fw)

    # # LIFTOFF_TOTAL_GENE_COUNT = 0
    # # LIFTOFF_BAD_PROT_TRANS_COUNT = 0
    # # LIFTOFF_GOOD_PROT_TRANS_COUNT = 0
    # # LIFTOFF_NC_TRANS_COUNT = 0
    # # LIFTOFF_OTHER_TRANS_COUNT = 0

    
    # # LIFTON_BAD_PROT_TRANS_COUNT = 0
    # # LIFTON_GOOD_PROT_TRANS_COUNT = 0
    # # LIFTON_NC_TRANS_COUNT = 0
    # # LIFTON_OTHER_TRANS_COUNT = 0
    # # LIFTON_MINIPROT_FIXED_GENE_COUNT = 0
    # print("Liftoff total gene loci\t\t\t: ", LIFTOFF_TOTAL_GENE_COUNT)
    # print("Liftoff total transcript\t\t\t: ", LIFTOFF_TOTAL_TRANS_COUNT)
    # print("Liftoff bad protein trans count\t\t\t: ", LIFTOFF_BAD_PROT_TRANS_COUNT)
    # print("Liftoff good protein trans count\t\t\t: ", LIFTOFF_GOOD_PROT_TRANS_COUNT)
    # print("Liftoff non-coding trans count\t\t\t: ", LIFTOFF_NC_TRANS_COUNT)
    # print("Liftoff OTHER trans count\t\t\t: ", LIFTOFF_OTHER_TRANS_COUNT)
    # print("\n\n")

    # print("LiftOn bad protein trans count\t\t\t: ", LIFTON_BAD_PROT_TRANS_COUNT)
    # print("LiftOn good protein trans count\t\t\t: ", LIFTON_GOOD_PROT_TRANS_COUNT)
    # print("LiftOn non-coding trans count\t\t\t: ", LIFTON_NC_TRANS_COUNT)
    # print("LiftOn OTHER trans count\t\t\t: ", LIFTON_OTHER_TRANS_COUNT)
    # print("LiftOn miniprot fixed trans count\t\t\t: ", LIFTON_MINIPROT_FIXED_GENE_COUNT)

    # fw.close()
    # fw_truncated.close()
    # fw_other_trans.close()
    # fw_nc_trans.close()

def main(arglist=None):
    args = parse_args(arglist)
    print("Run Lifton!!")
    print(args)
    run_all_lifton_steps(args)