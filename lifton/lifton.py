from lifton import extract_features
import argparse
from pyfaidx import Fasta, Faidx
from intervaltree import Interval, IntervalTree
import copy

from lifton import align, adjust_cds_boundaries, fix_trans_annotation, lifton_class, lifton_utils

def parse_args(arglist):
    print("arglist: ", arglist)
    parser = argparse.ArgumentParser(description='Lift features from one genome assembly to another')
    parser.add_argument('target', help='target fasta genome to lift genes to')

    # refrgrp = parser.add_argument_group('Required input (annotation)')
    # mxgrp = refrgrp.add_mutually_exclusive_group(required=True)
    # mxgrp.add_argument(
    #     '-g', metavar='GFF', help='annotation file to lift over in GFF or GTF format'
    # )
    # mxgrp.add_argument(
    #     '-db', metavar='DB', help='name of feature database; if not specified, the -g '
    #                               'argument must be provided and a database will be built automatically'
    # )

    outgrp = parser.add_argument_group('Output')
    outgrp.add_argument(
        '-o', '--output', default='stdout', metavar='FILE',
        help='write output to FILE in same format as input; by default, output is written to terminal (stdout)'
    )

    outgrp.add_argument(
        '-d', '--dir', default='intermediate_files', metavar='DIR',
        help='name of directory to save intermediate fasta and SAM files; default is "intermediate_files"',
    )

    parser.add_argument('-V', '--version', help='show program version', action='version', version='v1.6.3')
    parser.add_argument(
        '-t', '--threads', default=1, type=int, metavar='P', help='use p parallel processes to accelerate alignment; by default p=1'
    )

    parser.add_argument(
        '-p', '--proteins', metavar='fasta', required=True,
        help='the reference protein sequences.'
    )

    liftoffrefrgrp = parser.add_argument_group('Required input (Liftoff annotation)')

    liftoffgrp = liftoffrefrgrp.add_mutually_exclusive_group(required=True)
    liftoffgrp.add_argument(
        '-l', '--liftoff', metavar='gff',
        help='the annotation generated by Liftoff'
    )
    liftoffgrp.add_argument(
        '-ldb', '--liftoffdb', metavar='gff-DB',
        help='name of Liftoff database; if not specified, the -liftoff '
                                  'argument must be provided and a database will be built automatically'
    )

    miniprotrefrgrp = parser.add_argument_group('Required input (miniprot annotation)')

    miniprotgrp = miniprotrefrgrp.add_mutually_exclusive_group(required=True)
    miniprotgrp.add_argument(
        '-m', '--miniprot', metavar='gff',
        help='the annotation generated by miniprot'
    )
    miniprotgrp.add_argument(
        '-mdb', '--miniprotdb', metavar='gff-DB',
        help='name of miniprot database; if not specified, the -miniprot '
                                  'argument must be provided and a database will be built automatically'
    )

    parser._positionals.title = 'Required input (sequences)'
    parser._optionals.title = 'Miscellaneous settings'

    parser._action_groups = [parser._positionals, liftoffrefrgrp, miniprotrefrgrp, outgrp, parser._optionals]
    args = parser.parse_args(arglist)
    return args



def run_all_liftoff_steps(args):
    ref_chroms = []
    fai = Fasta(args.target)
    print("fai: ", fai.keys())
    print(args.output)
    print(args.dir)

    fai_protein = Fasta(args.proteins)

    l_feature_db, m_feature_db = extract_features.extract_features_to_fix(ref_chroms, args)

    fw = open(args.output, "w")
    # fw_protein = open("lifton_protein.gff3", "w")

    
    ################################
    # Step 1: Creating miniprot 2 Liftoff ID mapping
    ################################
    m_id_dict = {}
    aa_id_2_m_id_dict = {}
    for feature in m_feature_db.features_of_type("mRNA"):
        # Print all attributes and their values for the feature
        miniprot_id = feature["ID"][0]

        aa_trans_id = str(feature.attributes["Target"][0]).split(" ")[0]
        # print("aa_trans_id: ", aa_trans_id)
        if aa_trans_id in m_id_dict.keys():
            m_id_dict[aa_trans_id].append(miniprot_id)
        else:
            m_id_dict[aa_trans_id] = [miniprot_id]
        aa_id_2_m_id_dict[miniprot_id] = aa_trans_id

    ###################################
    # Printing the miniprot dictionary
    ###################################
    # for key, vals in m_id_dict.items():
    #     print("key : ", key)
    #     print("vals: ", vals)


    ################################
    # Iterating Liftoff transcript
    ################################
    # # Iterate through the features in the database and collect unique feature types
    # print("l_feature_db.features_of_type('mRNA')", l_feature_db.all_features())
    # for feature in l_feature_db.all_features(strand="+"):
    # # for feature in l_feature_db.features_of_type("mRNA"):
    #     print("feature ", feature)


    # print(" m_feature_db.features_of_type('mRNA'):",  m_feature_db.all_features())
    # for feature in m_feature_db.features_of_type("mRNA"):
    #     print("feature ", feature)
    
    ################################
    # Step 2: Initializing intervaltree
    ################################
    tree_dict = {}
    chr_num_ls = [*range(1, 23)] 
    chr_num_ls += ['X', 'Y', 'M']
    for i in chr_num_ls:
        tree = IntervalTree()
        tree_dict["chr" + str(i)] = tree

    print(tree_dict)

    ################################
    # Step 3: Adding gene intervals into intervaltree
    ################################
    for gene in l_feature_db.features_of_type('gene'):
        gene_interval = Interval(gene.start, gene.end, gene.attributes["ID"][0])
        chromosome = gene.seqid
        tree_dict[chromosome].add(gene_interval)




    ################################
    # Step 3: Iterating gene entries & fixing CDS lists
    ################################
    # aa_trans_dict = {}
    for gene in l_feature_db.features_of_type('gene', limit=("chr17", 41948560, 41950148)):
    # for gene in l_feature_db.features_of_type('gene', limit=("chr1", 144405905, 144553176)):
    # for gene in l_feature_db.features_of_type('gene', limit=("NC_000069.7", 142270709, 142273588)):
        chromosome = gene.seqid
        gene_id = gene.attributes["ID"][0]

        lifton_gene = lifton_class.Lifton_GENE(gene)
        
        # Assumption that all 1st level are transcripts
        transcripts = l_feature_db.children(gene, level=1)  # Replace 'exon' with the desired 
        
        ###########################
        # Adding transcripts
        ###########################
        for transcript in list(transcripts):
            lifton_gene.add_transcript(transcript)
            transcript_id = transcript["ID"][0]
    
            exons = l_feature_db.children(transcript, featuretype='exon')  # Replace 'exon' with the desired child feature type

            ###########################
            # Adding exons
            ###########################
            for exon in list(exons):
                lifton_gene.add_exon(transcript_id, exon)

            cdss = l_feature_db.children(transcript, featuretype='CDS')  # Replace 'exon' with the desired child feature type
            
            ###########################
            # Adding CDS
            ###########################
            cds_num = 0
            for cds in list(cdss):
                cds_num += 1
                lifton_gene.add_cds(transcript_id, cds)


            #############################################
            # Case 1: There are no CDS in the transcript
            #############################################
            if (cds_num > 0) and (transcript_id in m_id_dict.keys()) and (transcript_id in fai_protein.keys()):
                ################################
                # Protein sequences are in both Liftoff and miniprot
                #   Fix the protein sequences
                ################################
                
                ################################
                # liftoff transcript alignment
                ################################
                l_lifton_aln = align.parasail_align("liftoff", l_feature_db, transcript, fai, fai_protein, transcript_id)


                ################################
                # miniprot transcript alignment
                ################################
                print("transcript_id: ", transcript_id)
                m_ids = m_id_dict[transcript_id]
                liftoff_miniprot_overlapping = False

                for m_id in m_ids:
                    # print("\tm_id: ", m_id)
                    m_entry = m_feature_db[m_id]
                    if m_entry.seqid != chromosome:
                        continue
                    
                    m_lifton_aln = align.parasail_align("miniprot", m_feature_db, m_entry, fai, fai_protein, transcript_id)
                    overlap = lifton_utils.segments_overlap((m_entry.start, m_entry.end), (transcript.start, transcript.end))


                    ############################################
                    # miniprot and Liftoff transcript overlap
                    #   => fix & update CDS list
                    ############################################
                    if overlap and m_entry.seqid == transcript.seqid:

                        # Check reference overlapping status
                        # 1. Check it the transcript overlapping with the next gene
                        
                        # Check the miniprot protein overlapping status

                        # The case I should not process the transcript 
                        # 1. The Liftoff does not overlap with other gene
                        # 2. The miniprot protein overlap the other gene
                        ovps_liftoff = tree_dict[chromosome].overlap(transcript.start, transcript.end)
                        ovps_miniprot = tree_dict[chromosome].overlap(m_entry.start, m_entry.end)
                        if len(ovps_liftoff) == 1 and len(ovps_miniprot) > 1:
                            print("Liftoff & miniprot disagree too much => skip")
                            print(transcript)
                            continue                            

                        
                        liftoff_miniprot_overlapping = True

                        cds_list = fix_trans_annotation.fix_transcript_annotation(m_lifton_aln, l_lifton_aln, fai, fw)
                        lifton_gene.update_cds_list(transcript_id, cds_list)

                        # if transcript.seqid == "rna-NM_001397211.1":
                        #     print("\tnew cds_list: ", len(lifton_gene.transcripts[transcript_id].exons))
                        #     # lifton_gene.transcripts[transcript_id].write_entry(fw)
                        #     print("Write out 2")
                        #     print(transcript_id)
                        #     print(m_entry)
                        #     # print(l_entry)
                        #     # print("miniprot_identity: ", miniprot_identity, "; number of children: ", len(m_lifton_aln.cds_children))
                        #     # print("liftoff_identity: ", liftoff_identity, "; number of children: ", len(l_lifton_aln.cds_children))
                        #     print("\n\n")

                ################################
                # Case 2: no miniprot and Liftoff transcripts overlap
                ################################
                # if not liftoff_miniprot_overlapping:
                #     print("Write out 3")
                    # lifton_gene.transcripts[transcript_id].write_entry(fw)
            # else:
            #     ################################
            #     # Keep the transcript as it is.
            #     #   (1) do not have proper protein sequences.
            #     #   (2) transcript_id not in proteins
            #     #   (3) transcript ID not in miniprot 
            #     ################################
            #     pass

            # aa_trans_dict[transcript_id] = lifton_gene.transcripts[transcript_id]

        lifton_gene.write_entry(fw)
        gene_interval = Interval(lifton_gene.entry.start, lifton_gene.entry.end, gene_id)
        tree_dict[chromosome].add(gene_interval)


    # print("aa_trans_dict len: ", len(aa_trans_dict))
    # # print("aa_trans_dict: ", aa_trans_dict)
    
    # for mtrans in m_feature_db.features_of_type('mRNA', limit=("chr1", 0, 250000000)):
    #     chromosome = mtrans.seqid

    #     mtrans_id = mtrans.attributes["ID"][0]

    #     mtrans_interval = Interval(mtrans.start, mtrans.end, mtrans_id)

    #     # print(">> chromosome: ", chromosome)
    #     # print(">> mtrans_interval: ", mtrans_interval)
    #     # print(">> tree_dict[chromosome]: ", tree_dict[chromosome])

    #     ovps = tree_dict[chromosome].overlap(mtrans_interval)

    #     if len(ovps) == 0:
    #         print("ovps: ", len(ovps))
    #         print(mtrans_interval)
    #         print(aa_id_2_m_id_dict[mtrans_id])
            

    #         # Find the extra copy for know gene
    #         if aa_id_2_m_id_dict[mtrans_id] in aa_trans_dict.keys():
    #             print("\tTransid found!!!")

    #             # # Query & write from know aa_trans
    #             # aa_trans_extra = aa_trans_dict[aa_id_2_m_id_dict[mtrans_id]]
    #             # # aa_trans_extra.update()
    #             # aa_trans_extra.write_entry(fw)

    #             # Write from Queried miniprot transcripts
    #             Lifton_trans = lifton_class.Lifton_TRANS(mtrans)
    #             cdss = m_feature_db.children(mtrans, featuretype='CDS')  # Replace 'exon' with the desired child feature type
    #             # print("cdss len: ", len(cdss))
    #             for cds in list(cdss):
    #                 Lifton_trans.add_exon(cds)
    #                 cds_copy = copy.deepcopy(cds)
    #                 Lifton_trans.add_cds(cds_copy)
    #             Lifton_trans.write_entry(fw)



    #         else:
    #             print("\tTransid not found!")
    #             Lifton_trans = lifton_class.Lifton_TRANS(mtrans)
    #             cdss = m_feature_db.children(mtrans, featuretype='CDS')  # Replace 'exon' with the desired child feature type
    #             # print("cdss len: ", len(cdss))
    #             for cds in list(cdss):
    #                 Lifton_trans.add_exon(cds)
    #                 cds_copy = copy.deepcopy(cds)
    #                 Lifton_trans.add_cds(cds_copy)
                
                
    #             #     cds_num += 1
    #             # print("cds_num: ", cds_num)
    #             # print("mtrans: ", Lifton_trans.entry)
    #             # print("exons: ", len(Lifton_trans.exons))
    #             # print("exon_dic: ", len(Lifton_trans.exon_dic))

    #             Lifton_trans.write_entry(fw)
                

    #         # print("aa_trans_extra: ", aa_trans_extra)






def main(arglist=None):
    args = parse_args(arglist)
    print("Run Lifton!!")
    print(args)
    run_all_liftoff_steps(args)