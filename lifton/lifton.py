from lifton import extract_features
import argparse
# from pyfaidx import Fasta, Faidx

def parse_args(arglist):
    print("arglist: ", arglist)
    parser = argparse.ArgumentParser(description='Lift features from one genome assembly to another')
    parser.add_argument('target', help='target fasta genome to lift genes to')

    # refrgrp = parser.add_argument_group('Required input (annotation)')
    # mxgrp = refrgrp.add_mutually_exclusive_group(required=True)
    # mxgrp.add_argument(
    #     '-g', metavar='GFF', help='annotation file to lift over in GFF or GTF format'
    # )
    # mxgrp.add_argument(
    #     '-db', metavar='DB', help='name of feature database; if not specified, the -g '
    #                               'argument must be provided and a database will be built automatically'
    # )

    outgrp = parser.add_argument_group('Output')
    outgrp.add_argument(
        '-o', default='stdout', metavar='FILE',
        help='write output to FILE in same format as input; by default, output is written to terminal (stdout)'
    )

    outgrp.add_argument(
        '-dir', default='intermediate_files', metavar='DIR',
        help='name of directory to save intermediate fasta and SAM files; default is "intermediate_files"',
    )

    parser.add_argument('-V', '--version', help='show program version', action='version', version='v1.6.3')
    parser.add_argument(
        '-p', default=1, type=int, metavar='P', help='use p parallel processes to accelerate alignment; by default p=1'
    )

    parser.add_argument(
        '-proteins', metavar='fasta', required=True,
        help='the reference protein sequences.'
    )

    liftoffrefrgrp = parser.add_argument_group('Required input (Liftoff annotation)')

    liftoffgrp = liftoffrefrgrp.add_mutually_exclusive_group(required=True)
    liftoffgrp.add_argument(
        '-liftoff', metavar='gff',
        help='the annotation generated by Liftoff'
    )
    liftoffgrp.add_argument(
        '-liftoffdb', metavar='gff-DB',
        help='name of Liftoff database; if not specified, the -liftoff '
                                  'argument must be provided and a database will be built automatically'
    )

    miniprotrefrgrp = parser.add_argument_group('Required input (miniprot annotation)')

    miniprotgrp = miniprotrefrgrp.add_mutually_exclusive_group(required=True)
    miniprotgrp.add_argument(
        '-miniprot', metavar='gff',
        help='the annotation generated by miniprot'
    )
    miniprotgrp.add_argument(
        '-miniprotdb', metavar='gff-DB',
        help='name of miniprot database; if not specified, the -miniprot '
                                  'argument must be provided and a database will be built automatically'
    )

    parser._positionals.title = 'Required input (sequences)'
    parser._optionals.title = 'Miscellaneous settings'

    parser._action_groups = [parser._positionals, liftoffrefrgrp, miniprotrefrgrp, outgrp, parser._optionals]
    args = parser.parse_args(arglist)
    return args



# def extract_features_to_lift(ref_chroms, liftover_type, parents_to_lift, args):
#     print("extracting features")
#     if os.path.exists(args.dir) is False:
#         os.mkdir(args.dir)
#     feature_db = create_feature_db_connections(args)
#     feature_hierarchy, parent_order = seperate_parents_and_children(feature_db, parents_to_lift)
#     get_gene_sequences(feature_hierarchy.parents, ref_chroms, args, liftover_type)
#     return feature_hierarchy, feature_db, parent_order


# def lift_original_annotation(ref_chroms, target_chroms, lifted_features_list, args, unmapped_features, parents_to_lift):
#     liftover_type = "chrm_by_chrm"
#     if target_chroms[0] == args.target and args.exclude_partial == False:
#         min_cov, min_seqid = 0.05, 0.05
#     else:
#         min_cov, min_seqid = args.a, args.s

#     feature_hierarchy, feature_db, ref_parent_order = extract_features.extract_features_to_lift(ref_chroms,
#                                                                                                 liftover_type,
#                                                                                                 parents_to_lift, args)

def run_all_liftoff_steps(args):
    print(">> run_all_lifton_steps")
    lifted_feature_list = {}
    unmapped_features = []

    liftover_type = "chrm_by_chrm"
    ref_chroms = []

    l_feature_hierarchy, l_feature_db, l_ref_parent_order, m_feature_hierarchy, m_feature_db, m_ref_parent_order = extract_features.extract_features_to_fix(ref_chroms, liftover_type, args)

    print("l_feature_hierarchy: ", l_feature_hierarchy)
    print("l_feature_db: ", l_feature_db)
    print("l_ref_parent_order: ", len(l_ref_parent_order))
    print("m_feature_hierarchy: ", m_feature_hierarchy)
    print("m_feature_db: ", m_feature_db)
    print("m_ref_parent_order: ", len(m_ref_parent_order))

def main(arglist=None):
    args = parse_args(arglist)
    print("Run Lifton!!")
    print(args)
    run_all_liftoff_steps(args)